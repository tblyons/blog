In my personal development, I've tried to keep all my non-stand-alone app ideas in a single library.
This desire can probably be traced back to my discovery of [JUCE](https://juce.com/).
JUCE is a single high-quality framework for building applications.
While it is organized by modules, it still contained a huge variety of functionality in a single library.

One of the projects that I would like to implement is a budgeting/double entry accounting app similar to [Ledger](https://www.ledger-cli.org/).
But every time I started implementing the app, I would get sidetracked by representing money.
Money typically has fractional components and all currencies I am aware of use decimal based representations.
But floating point types can't represent tenths or hundredths exactly!

```
class Decimal_float {
  float mValue;
public:
  Decimal_foat(float value) : mValue(value) { }
}; // class Decimal_float
```
* 7.2 decimal digits of precision
* Capable of representing $100 thousand precisely
* Size: 4 bytes
* Padding: 0 bytes

```
class Decimal_double {
  double mValue;
public:
  Decimal_double(double value) : mValue(value) { }
}; // class Decimal_double
```
* 15.9 decimal digits of precision
* Capable of representing $10 trillion precisely
* Size: 8 bytes
* Padding: 0 bytes

```
class Decimal_int32_int32 {
  int32_t mMantissa;
  int32_t mExponent;
public:
  Decimal_int32_int32(float value)
}; // class Decimal_int32_int32
```
* 9.3 decimal digits of precision
* Capable of representing $10 million precisely
* Size: 8 bytes
* Padding: 0 bytes

```
class Decimal_int64_int32 {
  int64_t mMantissa;
  int32_t mExponent;
public:
  Decimal_int64_int32(double value)
}; // class Decimal_int64_int32
```
* 18.9 decimal digits of precision
* Capable of representing $10,000 trillion precisely
* Size: 12 bytes
* Padding: 4 bytes

```
#include <iostream>
#include <ratio>

template <typename ratio>
class FixedPoint {
// Private member variables
  int64_t m_value;
public:
// Static class constants
  static constexpr auto numerator = ratio::num;
  static constexpr auto denominator = ratio::den;

// Constructors
  constexpr FixedPoint()
    : m_value() {}

  explicit constexpr FixedPoint(int64_t rep)
    : m_value(rep) { }

// Factory functions
  static constexpr auto from_double(double value) -> FixedPoint {
    return FixedPoint(static_cast<int64_t>(value * denominator) / numerator);
  }

  static constexpr auto from_float(double value) -> FixedPoint {
    return FixedPoint(static_cast<int64_t>(value * denominator) / numerator);
  }

// In-place arithmetic operators
  constexpr auto operator+=(FixedPoint const& other) -> FixedPoint& {
    m_value += other.m_value;
    return *this;
  }

  constexpr auto operator-=(FixedPoint const& other) -> FixedPoint& {
    m_value -= other.m_value;
    return *this;
  }

// Accessors
  constexpr auto whole_number() const -> int64_t {
    return (m_value * numerator) / denominator;
  }

  constexpr auto remainder() const -> int64_t {
    return (m_value * numerator) % denominator;
  }

  constexpr auto significand() const -> int64_t {
    return m_value;
  }

// Conversion operators
  constexpr operator double() const {
    return (static_cast<double>(m_value) * numerator) / denominator;
  }

  constexpr operator float() const {
    return (static_cast<float>(m_value) * numerator) / denominator;
  }

}; // struct FixedPoint

template <typename ratio_a, typename ratio_b>
constexpr auto operator*(FixedPoint<ratio_a> const& lhs, FixedPoint<ratio_b> const& rhs) {
  return FixedPoint<std::ratio_multiply<ratio_a, ratio_b>>(lhs.significand() * rhs.significand());
}

template <typename ratio_a, typename ratio_b>
constexpr auto operator/(FixedPoint<ratio_a> const& lhs, FixedPoint<ratio_b> const& rhs) {
  auto quotient = lhs.significand() / rhs.significand();
  std::cout << "quotient: " << quotient << std::endl;
  auto remainder = lhs.significand() % rhs.significand();
  if (0 != remainder) throw std::runtime_error("Error: Precision lost in division operation");
  return FixedPoint<std::ratio_divide<ratio_a, ratio_b>>(quotient);
}

int main() {
  FixedPoint<std::ratio<1,3>> a(10);
  FixedPoint<std::ratio<1,5>> b(1);
  auto quotient = a / b;
  std::cout << "Quotient: " << quotient.whole_number() << " + " << quotient.remainder() << " / " << quotient.denominator << std::endl;
  return quotient.whole_number();
}
```
This one was an interesting idea, but the loss of precision during division is a non-starter.

```
#include <iomanip>
#include <iostream>
#include <algorithm>

template <int Exp>
constexpr double pow10() {
  if constexpr (0 < Exp) {
    return pow10<Exp - 1>() * 10.0;
  }
  if constexpr (Exp < 0) {
    return pow10<Exp + 1>() / 10.0;
  }
  return 1.0;
}

template <int Exp>
class Decimal {
  long long int m_value;
public:
  static constexpr int exp = Exp;
  static constexpr double mul = pow10<Exp>();

  constexpr explicit Decimal(long long int value = 0)
    : m_value(value) { }

  constexpr explicit Decimal(double value) = delete;

  template <int E>
  constexpr Decimal<Exp>(const Decimal<E>& o)
    : m_value(o.template rebase<Exp>()) { }

  template <int E>
  constexpr auto rebase() const -> long long int {
    return m_value * pow10<exp - E>();
  }

  static constexpr auto from_double(double value) -> Decimal {
    return Decimal(static_cast<long long int>(value / mul));
  }

  constexpr operator double() const {
    return m_value * mul;
  }

  constexpr auto significand() const -> long long int {
    return m_value;
  }

  constexpr auto operator+=(Decimal const& rhs) {
    m_value += rhs.m_value;
    return *this;
  }

  constexpr auto operator-=(Decimal const& rhs) {
    m_value -= rhs.m_value;
    return *this;
  }

}; // class Decimal

template <int lexp, int rexp>
constexpr auto operator+(Decimal<lexp> const& lhs, Decimal<rexp> const& rhs) {
  constexpr int min_exp = std::min(lexp, rexp);
  return Decimal<min_exp>(lhs.template rebase<min_exp>() + rhs.template rebase<min_exp>());
}

template <int lexp, int rexp>
constexpr auto operator*(Decimal<lexp> const& lhs, Decimal<rexp> const& rhs) {
  return Decimal<lexp + rexp>(lhs.significand() * rhs.significand());
}

template <int lexp, int rexp>
constexpr auto operator/(Decimal<lexp> const& lhs, Decimal<rexp> const& rhs) {
  return Decimal<lexp - rexp>(lhs.significand() / rhs.significand());
}

int main() {
  auto cider = Decimal<-2>::from_double(9.99);
  auto tax = Decimal<-2>::from_double(0.60);
  auto total = cider + tax;
  auto taxable = total / Decimal<-2>::from_double(1.06);
  std::cout << taxable.significand() << " " << taxable.exp << std::endl;
  return 0;
}
```
Okay, this one is looking promising. Though, the division is not maintaining significant digits.
