In my personal development, I've tried to keep all my non-stand-alone app ideas in a single library.
This desire can probably be traced back to my discovery of [JUCE](https://juce.com/).
JUCE is a single high-quality framework for building applications.
While it is organized by modules, it still contained a huge variety of functionality in a single library.

One of the projects that I would like to implement is a budgeting/double entry accounting app similar to [Ledger](https://www.ledger-cli.org/).
But every time I started implementing the app, I would get sidetracked by representing money.
Money typically has fractional components and all currencies I am aware of use decimal based representations.
But floating point types can't represent tenths or hundredths exactly!

```
class Decimal_float {
  float mValue;
public:
  Decimal_foat(float value) : mValue(value) { }
}; // class Decimal_float
```
* 7.2 decimal digits of precision
* Capable of representing $100 thousand precisely
* Size: 4 bytes
* Padding: 0 bytes

```
class Decimal_double {
  double mValue;
public:
  Decimal_double(double value) : mValue(value) { }
}; // class Decimal_double
```
* 15.9 decimal digits of precision
* Capable of representing $10 trillion precisely
* Size: 8 bytes
* Padding: 0 bytes

```
class Decimal_int32_int32 {
  int32_t mMantissa;
  int32_t mExponent;
public:
  Decimal_int32_int32(float value)
}; // class Decimal_int32_int32
```
* 9.3 decimal digits of precision
* Capable of representing $10 million precisely
* Size: 8 bytes
* Padding: 0 bytes

```
class Decimal_int64_int32 {
  int64_t mMantissa;
  int32_t mExponent;
public:
  Decimal_int64_int32(double value)
}; // class Decimal_int64_int32
```
* 18.9 decimal digits of precision
* Capable of representing $10,000 trillion precisely
* Size: 12 bytes
* Padding: 4 bytes

```
#include <iostream>
#include <ratio>

template <typename ratio>
class FixedPoint {
// Private member variables
  int64_t m_value;
public:
// Static class constants
  static constexpr auto numerator = ratio::num;
  static constexpr auto denominator = ratio::den;

// Constructors
  constexpr FixedPoint()
    : m_value() {}

  explicit constexpr FixedPoint(int64_t rep)
    : m_value(rep) { }

// Factory functions
  static constexpr auto from_double(double value) -> FixedPoint {
    return FixedPoint(static_cast<int64_t>(value * denominator) / numerator);
  }

  static constexpr auto from_float(double value) -> FixedPoint {
    return FixedPoint(static_cast<int64_t>(value * denominator) / numerator);
  }

// In-place arithmetic operators
  constexpr auto operator+=(FixedPoint const& other) -> FixedPoint& {
    m_value += other.m_value;
    return *this;
  }

  constexpr auto operator-=(FixedPoint const& other) -> FixedPoint& {
    m_value -= other.m_value;
    return *this;
  }

// Accessors
  constexpr auto whole_number() const -> int64_t {
    return (m_value * numerator) / denominator;
  }

  constexpr auto remainder() const -> int64_t {
    return (m_value * numerator) % denominator;
  }

  constexpr auto significand() const -> int64_t {
    return m_value;
  }

// Conversion operators
  constexpr operator double() const {
    return (static_cast<double>(m_value) * numerator) / denominator;
  }

  constexpr operator float() const {
    return (static_cast<float>(m_value) * numerator) / denominator;
  }

}; // struct FixedPoint

template <typename ratio_a, typename ratio_b>
constexpr auto operator*(FixedPoint<ratio_a> const& lhs, FixedPoint<ratio_b> const& rhs) {
  return FixedPoint<std::ratio_multiply<ratio_a, ratio_b>>(lhs.significand() * rhs.significand());
}

template <typename ratio_a, typename ratio_b>
constexpr auto operator/(FixedPoint<ratio_a> const& lhs, FixedPoint<ratio_b> const& rhs) {
  auto quotient = lhs.significand() / rhs.significand();
  std::cout << "quotient: " << quotient << std::endl;
  auto remainder = lhs.significand() % rhs.significand();
  if (0 != remainder) throw std::runtime_error("Error: Precision lost in division operation");
  return FixedPoint<std::ratio_divide<ratio_a, ratio_b>>(quotient);
}

int main() {
  FixedPoint<std::ratio<1,3>> a(10);
  FixedPoint<std::ratio<1,5>> b(1);
  auto quotient = a / b;
  std::cout << "Quotient: " << quotient.whole_number() << " + " << quotient.remainder() << " / " << quotient.denominator << std::endl;
  return quotient.whole_number();
}
```
This one was an interesting idea, but the loss of precision during division is a non-starter.
